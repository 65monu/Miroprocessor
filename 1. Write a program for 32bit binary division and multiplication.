32 BIT DIVISION


.model small
.stack 100H
.386
.data
DATA1 dd 00000000H
DATA2 dd 00000000H
REM dd ?
QUO dd ?
msg db 10,13,"Enter the first no.:: $"
msg1 db 10,13,"Enter the second no.:: $"
msg2 db 10,13,"The Remainder is :: $"
msg3 db 10,13,"The Quotient is :: $"
.code
.startup
MOV AH,09
MOV DX,OFFSET msg
INT 21H
MOV EBX, 0
MOV ECX, 8
AGAIN:
MOV AH,01 ; Read the first number
INT 21H
CMP AL,'A'
JGE L5
JMP L6
L5: SUB AL,37H
L6: SUB AL,30H
SHL EBX,4
ADD BL,AL
LOOP AGAIN
MOV DATA1, EBX
MOV AH,09
MOV DX,OFFSET msg1
INT 21H
MOV EBX, 0
MOV ECX, 8
AGAIN1:
MOV AH,01 ; Read the second number
INT 21H
CMP AL,'A'
JGE L7
SUB AL, 30H
JMP L8
L7: SUB AL, 37H
L8: SHL EBX, 4
ADD BL, AL
LOOP AGAIN1
MOV DATA2, EBX
MOV EAX, 0 ; Clear EAX for division
MOV EAX, DATA1 ; Load dividend (32-bit) into EAX
MOV EBX, DATA2 ; Load divisor (32-bit) into EBX
XOR EDX, EDX ; Clear EDX (high 32 bits of dividend)
DIV EBX ; Divide EDX:EAX by EBX (EAX = quotient, EDX = remainder)
MOV REM, EDX ; Store remainder
MOV QUO, EAX ; Store quotient
MOV AH,09
MOV DX,OFFSET msg2
INT 21H
MOV EBX, REM
MOV CX,8
AGAIN2:
ROL EBX,4
MOV DL,BL
AND DL,0FH
CMP DL,9
JBE L1
ADD DL,37H
MOV AH,02
INT 21H
JMP L2
L1: ADD DL,30H
MOV AH,02
INT 21H
L2: LOOP AGAIN2
MOV AH,09
MOV DX,OFFSET msg3
INT 21H
MOV EBX, QUO
MOV CX,8
AGAIN3:
ROL EBX, 4
MOV DL,BL
AND DL,0FH
CMP DL,9
JBE L3
ADD DL,37H
MOV AH,02
INT 21H
JMP L4
L3: ADD DL,30H
MOV AH,02
INT 21H
L4: LOOP AGAIN3
END



                                                                                  32 BIT MULTIPLICATIO
.model small
.stack 100H
.386
.data
DATA1 dd 00000000H
DATA2 dd 00000000H
PROD dd ?
msg db 10,13,"Enter the First Number: $"
msg1 db 10,13,"Enter the Second Number: $"
msg2 db 10,13,"The Product (in Hexadecimal) is: $"
.code
.startup
MOV AH, 09
MOV DX, OFFSET msg
INT 21H
MOV EBX, 0
MOV CX, 8
CALL READ_HEX ; Read the first number
MOV DATA1, EBX
MOV AH, 09
MOV DX, OFFSET msg1
INT 21H
MOV EBX, 0
MOV CX, 8
CALL READ_HEX ; Read the second number
MOV DATA2, EBX
MOV EAX, DATA1 ; Load first number into EAX
MOV EBX, DATA2 ; Load second number into EBX
MUL EBX ; Multiply EAX by EBX (result in EDX:EAX)
MOV PROD, EAX ; Store the lower 32 bits of the product
32 BIT MULTIPLICATION
MOV AH, 09
MOV DX, OFFSET msg2
INT 21H
MOV EBX, PROD
MOV CX, 8
CALL DISPLAY_HEX ; Display the product
; Exit the program
MOV AH, 4CH ; DOS function: Exit program
INT 21H
READ_HEX PROC ; Procedure to read a hexadecimal number
MOV EBX, 0
MOV CX, 8
READ_AGAIN:
MOV AH, 01 ; Read character from input
INT 21H
CMP AL,'A'
JGE L5
SUB AL, 30H
JMP L6
L5: SUB AL,37H
L6: SHL EBX, 4
ADD BL, AL
LOOP READ_AGAIN
RET
READ_HEX ENDP
DISPLAY_HEX PROC ; Procedure to display a hexadecimal number
AGAIN:
ROL EBX, 4
MOV DL, BL
AND DL, 0FH
CMP DL, 9
JBE L1
ADD DL, 37H
MOV AH, 02
INT 21H
JMP L2
L1: ADD DL, 30H
MOV AH, 02
INT 21H
L2: LOOP AGAIN
RET
DISPLAY_HEX ENDP
END
